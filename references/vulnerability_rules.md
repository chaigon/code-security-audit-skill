# 各语言安全漏洞检查规则

## 目录

- [通用规则](#通用规则)
  - [敏感信息泄露](#敏感信息泄露)
  - [注入类漏洞](#注入类漏洞)
  - [认证与授权](#认证与授权)
  - [加密问题](#加密问题)
  - [配置安全](#配置安全)
  - [业务逻辑缺陷](#业务逻辑缺陷)
  - [供应链安全](#供应链安全)
- [Python](#python)
- [Node.js / JavaScript](#nodejs--javascript)
  - [NoSQL 注入](#nosql-注入)
  - [前端安全](#前端安全)
- [Go](#go)
- [Java](#java)

---

## 通用规则

### 敏感信息泄露
- 硬编码密码、API Key、Token、Secret
- 搜索模式: `password\s*=`, `api_key`, `secret`, `token`, `AWS_ACCESS_KEY`, `PRIVATE_KEY`
- .env 文件是否被 .gitignore 排除
- 日志中是否打印敏感信息

### 注入类漏洞
- SQL 注入: 字符串拼接构造 SQL 语句
- 命令注入: 用户输入直接传入 shell 命令
- LDAP 注入、XPath 注入、模板注入

### 认证与授权
- 弱密码策略
- 缺少认证中间件
- 水平/垂直越权
- JWT 配置不当（无过期、弱密钥、alg=none）
- Session 固定攻击

### 加密问题
- 使用弱加密算法: MD5, SHA1, DES, RC4
- ECB 模式
- 硬编码 IV/Salt
- 不安全的随机数生成

### 配置安全
- DEBUG 模式在生产环境开启
- CORS 配置过于宽松 (`*`)
- 缺少安全 HTTP 头 (CSP, HSTS, X-Frame-Options)
- 不安全的 TLS 配置

### 业务逻辑缺陷

> 此类漏洞无法通过简单的模式匹配发现，需要理解业务上下文和数据流。

#### IDOR（不安全的直接对象引用）
- 搜索模式: `req.params.id`, `req.params.pk`, `request.args.get('id')`, `@PathVariable`
- 确认方法: 检查路由处理函数中是否将 URL 参数与当前用户身份做关联校验
- 高风险端点: 购物车、订单、地址、支付方式、用户资料等个人数据 CRUD
- 典型漏洞: `Model.findByPk(req.params.id)` 未校验 `req.params.id` 是否属于 `req.user`

#### Mass Assignment（批量赋值）
- 搜索模式: `Model.create(req.body)`, `instance.update(req.body)`, `Object.assign(user, req.body)`
- Sequelize: 检查 `create()`/`update()` 是否使用 `{ fields: [...] }` 白名单
- Django: 检查 `ModelForm` 是否定义了 `fields`（而非 `fields = '__all__'`）
- Spring: 检查 `@RequestBody` 是否直接绑定到实体类（应使用 DTO）
- 高风险场景: 用户注册时可注入 `role`/`isAdmin`/`isActive` 字段

#### 数值校验缺失
- 搜索模式: `quantity`, `price`, `amount`, `discount`, `total` 相关赋值
- 检查: 是否允许负数（负数订单量导致退款）、零值、超大值
- 检查: 价格/总额是否由客户端传入而非服务端计算
- 检查: 折扣/优惠券验证逻辑是否可被逆向（弱编码如 base64、z85）

#### 竞态条件
- 搜索模式: 余额扣减、库存扣减、优惠券使用次数
- 检查: 读取-修改-写入操作是否在数据库事务中执行
- 检查: 是否使用乐观锁/悲观锁防止并发问题
- 典型漏洞: 先查余额再扣款，两步之间可被并发请求利用

#### CSRF 防护缺失
- 检查: 状态变更操作（密码修改、邮箱修改、删除）是否使用 POST/PUT/DELETE
- 检查: 框架级 CSRF 中间件是否启用（Express `csurf`、Django `CsrfViewMiddleware`）
- 检查: Cookie 是否设置 `SameSite` 属性
- 高风险: 使用 GET 方法执行写操作（如 `GET /change-password?new=xxx`）

#### 反自动化缺失
- 检查: 登录、注册、密码重置是否有速率限制（`express-rate-limit`、`django-ratelimit`）
- 检查: CAPTCHA 实现是否可被重放（同一 captchaId 多次使用）
- 检查: 密码/token 比较是否使用 constant-time 函数（`crypto.timingSafeEqual`）
- 检查: 安全问题答案是否明文存储且可被暴力枚举

### 供应链安全

#### Typosquatting 检测
- 策略: 将依赖名与知名包名做编辑距离比较（如 `lodash` vs `1odash`、`express` vs `expres`）
- 检查: 是否有非官方 scope 的包（如 `@myscope/react` 冒充 `react`）
- 检查: 包名中是否有可疑字符替换（`0` 替换 `o`、`1` 替换 `l`）

#### 废弃包检测
- 检查: 依赖是否已被标记为 deprecated（`npm info <pkg> deprecated`）
- 检查: 依赖最后更新时间是否超过 2 年且有已知未修复漏洞
- 检查: 是否使用了已知被接管的包（如 `event-stream` 事件）

#### 可疑依赖来源
- 检查: 依赖是否指向 GitHub fork 而非官方仓库
- 检查: `postinstall` 脚本是否执行可疑操作（下载外部文件、反弹 shell）
- 检查: 依赖是否有过所有权转移历史

---

## Python

### 高危
- `eval()`, `exec()`, `compile()` 使用用户输入
- `pickle.loads()` 反序列化不可信数据
- `yaml.load()` 未使用 `SafeLoader`
- `subprocess.call(shell=True)` + 用户输入
- `os.system()` + 字符串拼接
- `__import__()` 动态导入
- Flask/Django `DEBUG=True` 在生产环境
- `render_template_string()` + 用户输入 (SSTI)

### 中危
- `requests.get(verify=False)` 禁用 SSL 验证
- `hashlib.md5()` / `hashlib.sha1()` 用于密码
- `random` 模块用于安全场景（应使用 `secrets`）
- Django `ALLOWED_HOSTS = ['*']`
- Flask `secret_key` 硬编码
- SQLAlchemy `text()` + 字符串拼接

### 低危
- 未设置 `httponly` / `secure` cookie 标志
- 缺少 CSRF 保护
- 过于宽泛的异常捕获 `except Exception`
- 未限制文件上传大小/类型

### 依赖文件
- `requirements.txt`, `Pipfile`, `Pipfile.lock`, `pyproject.toml`, `setup.py`, `setup.cfg`
- 审计工具: `pip-audit`, `safety`, `bandit`

---

## Node.js / JavaScript

### 高危
- `eval()`, `Function()`, `vm.runInNewContext()` + 用户输入
- `child_process.exec()` + 字符串拼接
- `require()` 动态路径 + 用户输入
- `innerHTML` / `dangerouslySetInnerHTML` + 未转义输入 (XSS)
- `new Function(userInput)` 代码注入
- 原型污染: `Object.assign({}, userInput)`, `_.merge`
- `express` 未使用 `helmet`
- `jsonwebtoken` 使用 `algorithms: ['none']`

### 中危
- `cors({ origin: '*' })` 过于宽松
- `express.static()` 路径遍历
- `fs.readFile(userInput)` 路径遍历
- `crypto.createCipher()` (已废弃，应使用 `createCipheriv`)
- `Math.random()` 用于安全场景
- 缺少 rate limiting
- `npm` 包 typosquatting 风险

### 低危
- 未设置 `sameSite` cookie 属性
- `console.log` 打印敏感信息
- 未处理的 Promise rejection
- 缺少输入长度限制

### 依赖文件
- `package.json`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`
- 审计工具: `npm audit`, `yarn audit`, `snyk`

### NoSQL 注入

#### MongoDB $where 注入
- 搜索模式: `$where`, `mapReduce`, `group`
- 高危: `collection.find({ $where: 'this.name === "' + userInput + '"' })` — 用户输入直接拼接到 $where 表达式
- 高危: `db.eval()` + 用户输入

#### 操作符注入
- 搜索模式: `req.body` 直接传入 MongoDB 查询条件
- 高危: `User.find({ email: req.body.email, password: req.body.password })` — 攻击者可传入 `{ "$ne": "" }` 绕过认证
- 检查: 查询条件中的值是否经过类型校验（确保是 string 而非 object）
- 常见可利用操作符: `$gt`, `$ne`, `$regex`, `$in`, `$exists`

#### 搜索注入
- 搜索模式: `$regex` + 用户输入
- 中危: `Model.find({ name: { $regex: userInput } })` — 可导致 ReDoS 或信息泄露
- 修复: 对用户输入进行正则转义或使用 `$text` 搜索

### 前端安全

#### XSS Sink
- Angular: `[innerHTML]=`, `bypassSecurityTrustHtml()`, `bypassSecurityTrustScript()`, `bypassSecurityTrustUrl()`, `bypassSecurityTrustResourceUrl()`
- React: `dangerouslySetInnerHTML`
- Vue: `v-html`
- 通用: `document.write()`, `element.innerHTML =`, `element.outerHTML =`, `insertAdjacentHTML()`

#### 前端路由泄露
- 搜索模式: 路由配置文件中的 `path:` 定义
- 检查: 是否有隐藏的管理页面路径（如 `/admin`, `/accounting`, `/score-board`）未在 UI 中展示但可直接访问
- 检查: 路由守卫（`canActivate`/`beforeEnter`）是否仅在前端校验而无后端配合

#### 前端硬编码凭据
- 搜索模式: `apiKey`, `secret`, `password`, `token`, `authorization` 在 `.ts`/`.js`/`.vue`/`.jsx` 文件中
- 检查: 前端代码中是否硬编码了 API 密钥、管理员凭据、JWT secret
- 检查: 环境变量是否通过构建工具注入到前端 bundle 中（如 `process.env.SECRET`）

---

## Go

### 高危
- `database/sql` 字符串拼接 SQL（应使用参数化查询）
- `os/exec.Command()` + 用户输入
- `html/template` 中使用 `template.HTML()` 绕过转义
- `net/http` 未设置超时 (DoS 风险)
- `crypto/rand` 未使用（使用了 `math/rand`）
- `unsafe` 包的不当使用
- `cgo` 中的内存安全问题

### 中危
- `http.ListenAndServe` 未使用 TLS
- `tls.Config{InsecureSkipVerify: true}`
- `ioutil.ReadAll` 未限制大小 (OOM 风险)
- `filepath.Join` + 用户输入未校验 (路径遍历)
- `json.Unmarshal` 到 `interface{}` 未校验类型
- goroutine 泄露（无 context 取消）

### 低危
- 未使用 `defer` 关闭资源
- 错误被忽略 `_ = someFunc()`
- 缺少 context 传播
- 未设置 CORS 中间件

### 依赖文件
- `go.mod`, `go.sum`
- 审计工具: `govulncheck`, `gosec`

---

## Java

### 高危
- SQL 注入: `Statement` + 字符串拼接（应使用 `PreparedStatement`）
- `Runtime.getRuntime().exec()` + 用户输入
- `ObjectInputStream.readObject()` 反序列化不可信数据
- XXE: `DocumentBuilderFactory` 未禁用外部实体
- SSRF: `URL.openConnection()` + 用户输入
- SpEL 表达式注入
- Log4j JNDI 注入 (`${jndi:ldap://}`)
- Fastjson `autoType` 开启

### 中危
- `MessageDigest.getInstance("MD5")` 用于密码
- `SecureRandom` 使用固定种子
- Spring `@CrossOrigin` 过于宽松
- Mybatis `${}` 拼接（应使用 `#{}`）
- `File` 操作未校验路径
- Swagger/OpenAPI 在生产环境暴露
- Spring Actuator 端点未保护

### 低危
- 异常信息泄露堆栈跟踪
- 未使用 `finally` 关闭资源（Java 7+ 应使用 try-with-resources）
- `@RequestMapping` 未限制 HTTP 方法
- 缺少输入校验注解 (`@Valid`, `@NotNull`)

### 依赖文件
- `pom.xml`, `build.gradle`, `build.gradle.kts`
- 审计工具: `OWASP dependency-check`, `SpotBugs`, `FindSecBugs`

---

## 攻击链模式

> 单个漏洞的影响有限，但多个漏洞组合可构建高危攻击路径。Phase 4 中应主动寻找以下模式。

### 典型攻击链

| 模式 | 链路 | 最终影响 |
|------|------|---------|
| 认证绕过 → 功能滥用 | Token 伪造 → 管理 API → 系统控制 | 全系统沦陷 |
| 认证绕过 → SSRF | JWT 伪造 → SSRF → 云元数据 → 获取凭据 | 云环境接管 |
| 认证绕过 → 注入 | Token 伪造 → 创建数据源 → SQL/命令执行 | 服务器 RCE |
| 信息泄露 → 认证绕过 | 密钥接口暴露 → 伪造 Token → 全系统访问 | 全系统沦陷 |
| 配置缺陷 → 数据窃取 | CORS * → 恶意页面 → 跨域读取数据 | 用户数据泄露 |
| IDOR + 白名单绕过 | 未认证端点 + ID 可枚举 → 批量数据泄露 | 大规模数据泄露 |
| 弱加密 → 伪造 | 可逆编码(base64/z85) → 伪造优惠券/Token | 业务逻辑绕过 |

### 攻击链构建规则

1. **前置条件消除**：漏洞 A 的利用结果消除漏洞 B 的前置条件 → A+B 构成攻击链
2. **等级提升**：链中最终影响决定组合等级，而非单个漏洞等级之和
3. **根漏洞优先**：修复攻击链的根漏洞（通常是认证绕过或信息泄露）可同时阻断多条链路
4. **独立评级不变**：攻击链不改变单个漏洞的独立评级，组合等级单独标注

### 数据流追踪指南

追踪数据流时，关注以下关键转换点：

| 转换类型 | 检查要点 | 常见绕过 |
|---------|---------|---------|
| 类型转换 | 字符串→数字、JSON→对象 | 类型混淆、操作符注入 |
| 编码转换 | URL编码、Base64、Unicode | 双重编码、规范化绕过 |
| 过滤/校验 | 黑名单、正则、长度限制 | 不完整黑名单、ReDoS、截断 |
| 序列化/反序列化 | JSON、XML、二进制格式 | 反序列化 gadget、XXE |
| 路径处理 | 拼接、规范化、遍历检查 | null 字节、`../`、符号链接 |
